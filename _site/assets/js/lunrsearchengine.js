
var documents = [{
    "id": 0,
    "url": "http://0.0.0.0:4000/404.html",
    "title": "404",
    "body": "404 Cette page n'existe pas !Veuillez utiliser le champ de recherche ou retournez sur notre page d'accueil ! "
    }, {
    "id": 1,
    "url": "http://0.0.0.0:4000/categories",
    "title": "Categories",
    "body": ""
    }, {
    "id": 2,
    "url": "http://0.0.0.0:4000/",
    "title": "Home",
    "body": "      Articles:                                                                                                     Le â€œMessagerâ€ : un projet pas comme les autres chez Primobox              :       Trouver une entreprise dans laquelle on peut progresser, apprendre, innover, tout en forgeant un logiciel de qualitÃ© et des compÃ©tences partageables Ã  tout le monde, nâ€™est pas chose courante. Primobox est de cette trempe lÃ . Laissez-moi vous raconter briÃ¨vement cette aventure que jâ€™ai eu la chance de vivre. :                                                                                           Guillaume Saint Etienne                2 fÃ©vrier 2022                           20 minutes                                                                                                                             L'Outside-in Diamond TDD, ou l'art de mieux tester              :       Comment Ã©crire des tests orientÃ©s mÃ©tier, rapides, et qui vont couvrir le plus de code possible dans votre hexagone. :                                                                                           Vincent Dubois                15 janvier 2022                           7 minutes                                    "
    }, {
    "id": 3,
    "url": "http://0.0.0.0:4000/robots.txt",
    "title": "",
    "body": "      Sitemap: {{ â€œsitemap. xmlâ€   absolute_url }}   "
    }, {
    "id": 4,
    "url": "http://0.0.0.0:4000/le-messager/",
    "title": "Le â€œMessagerâ€ : un projet pas comme les autres chez Primobox",
    "body": "2022/02/02 - Trouver une entreprise dans laquelle on peut progresser, apprendre, innover, tout en forgeant un logiciel de qualitÃ© et des compÃ©tences partageables Ã  tout le monde, nâ€™est pas chose courante. Primobox est de cette trempe lÃ . Laissez-moi vous raconter briÃ¨vement cette aventure que jâ€™ai eu la chance de vivre. GenÃ¨se: Vous connaissez lâ€™adage â€œDiviser pour mieux rÃ©gnerâ€ ? Câ€™est ce que nous invite Ã  faire lâ€™approche DDD (Domain Driven Design). Et câ€™est avec ce principe en tÃªte (dÃ©limiter des Contextes Explicites et Discrets 1) quâ€™un projet de Messager autonome est nÃ© chez Primobox (pour faire simple, le Messager est celui chargÃ© de remettre le courrier Ã  ses destinataires). DotÃ© dâ€™une grande responsabilitÃ©, simple au premier abord mais qui permet dâ€™envisager des options et des possibilitÃ©s multiples, en toute autonomie. Une fois ce domaine (contexte) mÃ©tier spÃ©cifique identifiÃ© , parmi les autres besoins clients que doivent satisfaire les solutions proposÃ©es par Primobox, il Ã©tait plus facile de lancer un chantier ciblÃ© de modernisation du code. Avec un pÃ©rimÃ¨tre et des relations bien dÃ©finis, ce vÃ©ritable â€œmÃ©tier dans le mÃ©tierâ€ allait pouvoir prendre son envol. Vision: Un projet rÃ©ussi commence par une vision. Alexandre Fillatre, CTO chez Primobox a su initier et nourrir cette vision. BasÃ©e sur une idÃ©e simple : les diffÃ©rentes phases qui composent lâ€™activitÃ© de lâ€™offre de service chez Primobox (dÃ©matÃ©rialisation de la relation entre employÃ©s et employeurs) ont chacune une raison dâ€™exister propre, tout en Ã©tant capable dâ€™interagir avec les autres parties et dâ€™Ã©voluer de maniÃ¨re autonome. Alexandre nous a partagÃ© cette vision et nous a fait confiance pour la mettre en Å“uvre. Utilisateurs: En amont, un vrai travail pour comprendre le besoin utilisateur avait Ã©tÃ© initiÃ© et je lâ€™ai traduit en Ã©lÃ©ments que nous allions mettre dans le cÅ“ur du â€œMessagerâ€. Lâ€™atelier de Wording et les User Journeys mâ€™ont Ã©tÃ© trÃ¨s utiles pour cerner le domaine mÃ©tier dans son ensemble et dans ses particularitÃ©s. ClartÃ©: La clartÃ© se gagne par lâ€™analyse. GrÃ¢ce aux travaux prÃ©liminaires de lâ€™Ã©quipe Produit et Ergonomie, jâ€™ai pu coucher sur le papier une carte (Ã  la Wardley) des interactions entre le Messager et les autres Ã©lÃ©ments qui constituent la solution globale dont nos clients ont besoin. Cela permet de savoir quelles fonctionnalitÃ©s sont plus importantes, lesquelles sont annexes, lesquelles sont laissÃ©es Ã  la responsabilitÃ© dâ€™autres modules (existants ou Ã  crÃ©er) voire externalisÃ©es. Des choix stratÃ©giques importants sur le pÃ©rimÃ¨tre fonctionnel ont Ã©tÃ© faits afin de rÃ©duire la charge de travail et la complexitÃ© prÃ©sente sur certains produits. Cela dessine une forme dâ€™architecture, plus basÃ©e sur les besoins que la technique. Cela nous libÃ¨re aussi des dÃ©tails techniques, car sur un Context Mapping (toujours cette notion de cartographie) se dessinent les frontiÃ¨res entre les Bounded Contexts; et lâ€™on voit facilement les choix contraints par lâ€™existant (legacy), et par ailleurs les espaces oÃ¹ les contraintes changent de nature. Par exemple, lÃ  oÃ¹ la performance est plus importante que la compatibilitÃ©. Audace: Prendre des paris audacieux, aprÃ¨s tout, pourquoi pas ? Pourquoi rester conforme Ã  ce qui a Ã©tÃ© fait par le passÃ© et se priver de progresser ? Parlons du langage de dÃ©veloppement. Primobox a un historique Java solidement ancrÃ©. Moi jâ€™arrivais du monde . Net. Alexandre Fillatre a su discerner quâ€™un bon dÃ©veloppeur ne saurait sâ€™arrÃªter Ã  une syntaxe donnÃ©e, lâ€™essentiel Ã©tant ce que lâ€™on sait obtenir de tel ou tel langage de dÃ©veloppement. La POO est une chose universelle mais les langages modernes Ã©voluent pour Ãªtre plus hydrides et flirtent plus facilement avec la Programmation Fonctionnelle. Câ€™est le cas de C#, puis de Java qui lui a emboÃ®tÃ© le pas. Quitte Ã  sâ€™Ã©loigner de C# 9 pour aborder la JVM, autant opter pour un langage du mÃªme niveau. Câ€™est lÃ  que nous avons pensÃ© Ã  â€¦ Kotlin ! Etant pour ma part un adepte prÃ©coce de C# et de lâ€™Ã©cosystÃ¨me . Net, je nâ€™avais jamais eu Ã  me frotter au monde Java ailleurs que dans mes Ã©tudes. GrÃ¢ce Ã  Kotlin, franchir le cap a Ã©tÃ© pour moi dâ€™une facilitÃ© dÃ©concertante. Jâ€™ai retrouvÃ© tous mes rÃ©flexes acquis en C# avec une syntaxe encore plus Ã©lÃ©gante. Ayant lâ€™habitude de Linq, Kotlin est naturellement provisionnÃ© pour faire la mÃªme chose. En mieux ! Et il est facile de trouver de lâ€™aide et des exemples. Et des trÃ¨s bons tutos. ArriÃ¨re boutique: Ah oui, si vous cherchez des ressources sur Kotlin dans les Internets, vous verrez que ce langage est la panacÃ©e pour les applications mobiles. Et pourtant ! Câ€™est excessivement rÃ©ducteur. Kotlin produit (aussi) du bytecode qui va tourner sur la JVM. Donc câ€™est un parfait candidat pour tout le code backend. Câ€™est ce que nous avons fait pour cette application complexe, avec une architecture trÃ¨s Ã©voluÃ©e, ce qui nous a permis dâ€™Ãªtre parfaitement intÃ©grÃ© dans lâ€™existant Java et surtout trÃ¨s performant. Idiomes: Quitte Ã  choisir un langage qui nous Ã©tait inconnu (Ã  moi et mon coreligionnaire, pur Javaiste pour sa part) jusquâ€™ici, autant le faire bien et complÃ¨tement. Kotlin a de multiples talents. Facile dâ€™apprentissage, il emprunte un peu Ã  Typescript, C#, Scala et bien sÃ»r Java, puisquâ€™il produit du bytecode ciblÃ© pour la JVM. Son Ã©diteur (Jetbrains) a tout fait pour que les dÃ©veloppeurs Java sâ€™y retrouvent, et puissent mÃªme rÃ©-utiliser nâ€™importe quelle classe du JDK ou nâ€™importe quelle lib Java. Et Ã§a fonctionne trÃ¨s bien. On peut mÃªme Ã©crire du code â€œfaÃ§on Javaâ€ (utiliser des exceptions, mettre des if en pagaille, des null partoutâ€¦). Bref, si on nâ€™y prenait garde, on Ã©crirait presque du Kotlin qui ressemble Ã  du â€œmauvaisâ€ Java (je veux dire par lÃ  du Java dâ€™avant guerre, avant la version 8 si vous prÃ©fÃ©rezâ€¦). Pourtant avec Kotlin, tout est fait pour Ã©crire du code â€œÃ©lÃ©gantâ€. Jâ€™en veux pour preuve la non nullabilitÃ© des types par dÃ©faut, lâ€™immutabilitÃ© par dÃ©faut, la prÃ©sence des data classes (Ã©quivalent des Records de C# ou Java 16) parmi tant de choses qui mâ€™ont enchantÃ©es. On notera aussi que Kotlin dispose nativement de structures de donnÃ©es avancÃ©es (Pair, Triple, Linked List, Tree, etcâ€¦) et de possibilitÃ©s de manipulation de fonctions qui sont juste dÃ©licieuses. Et jâ€™allais oublier de mentionner les trÃ¨s puissantes co-routines. Attention: Tout au long de notre travail, une attention particuliÃ¨re a Ã©tÃ© portÃ©e aux autres membres de lâ€™Ã©quipe. Nous avons communiquÃ© rÃ©guliÃ¨rement :  sur lâ€™avancÃ©e du projet, mÃªme si nous nâ€™avions pas de revue de sprint (on en parle plus loin), sur les innovations ou techniques que nous avions choisi de mettre en Å“uvre, car celles-ci pouvaient aussi trouver leur place dans dâ€™autres projets du groupe. Nous sommes aussi dans une dÃ©marche dâ€™invitation permanente : tous les autres membres de la R&amp;D peuvent venir collaborer au projet, apprendre Kotlin ou tout autre concept que nous avons mis en Å“uvre. Langage Naturel: Le langage des utilisateurs et des experts mÃ©tier a Ã©tÃ© le nÃ´tre tout le long de la rÃ©alisation. Pas de jargon de dÃ©veloppeurs. Notre domaine mÃ©tier est en franÃ§ais. Toute la modÃ©lisation et le codage du logiciel se sont donc faits dans cette belle langue. Nous avons rÃ©servÃ© lâ€™anglais pour les parties purement techniques (logÃ©es dans des composants isolÃ©s et accessibles via les Ports &amp; Adaptateurs, conformÃ©ment Ã  lâ€™architecture hexagonale exposÃ©e plus loin); par exemple la mÃ©canique dâ€™accÃ¨s Ã  la base de donnÃ©es ou au bus de message. Câ€™est trÃ¨s pratique pour se rendre compte au premier coup dâ€™Å“il si notre mÃ©tier (en franÃ§ais) reste pur et ne se mÃ©lange pas avec des considÃ©rations techniques (en anglais). StratÃ©gie: Lâ€™approche DDD est un guide dans la nuit. Ce nâ€™est pas Ã  proprement parler une mÃ©thode, et surtout pas un framework. Câ€™est un ensemble dâ€™outils et de bonnes pratiques, tout Ã  fait compatible avec lâ€™agilitÃ© et le software craftsmanship. Nous avons eu cette approche dâ€™emblÃ©e, dÃ¨s les premiÃ¨res heures du projet. Câ€™est, il me semble, la condition sine qua non pour rÃ©ussir.  Comme dit prÃ©cÃ©demment, jâ€™ai commencÃ© par la mise en place dâ€™une Wardley Map, puis avec Damien BouÃ© nous avons travaillÃ© sur des Bounded Contexts Maps. Cela nous a permis de nous synchroniser aussi avec les Ã©quipes Produit. Tactique: En DDD la stratÃ©gie sâ€™accompagne toujours dâ€™une tactique, je ne vais pas vous faire ici un cours de DDD, les ressources sur Internet ne manquent pas. Je ne vais pas vous parler ici des essentielles dÃ©compositions en agrÃ©gats, entitÃ©s et value objects (chasser la Primitive Obsession). Je vous dirai seulement quâ€™une des leÃ§ons que nous avons apprises est de songer sÃ©rieusement Ã  limiter la taille de nos agrÃ©gats ! (cf ces bons conseils peu connus de Vaughn Vernon) Jusquâ€™Ã  ce quâ€™ils ne contiennent quâ€™une entitÃ©. Cette idÃ©e peut vous paraÃ®tre saugrenue mais vous lui direz merci quand vous verrez la complexitÃ© accidentelle poindre son nez. Bien sÃ»r cela demande Ã  rÃ©flÃ©chir plus et surtout Ã  ne pas se laisser entraÃ®ner par une conception basÃ©e sur le Mapping Objet Relationnel (ORM ou Objet Documents Mapping dans le cas des entrepÃ´ts NoSQL) qui, entre autres inconvÃ©nients, pousse notre modÃ¨le Ã  Ãªtre anÃ©mique. Mais aussi lorsque lâ€™exÃ©cution de nos adapters devient concurrente (comme dans toutes les API Web), nous aurait obligÃ© Ã  poser des verrous transactionnels (et donc faire effondrer la performance). Cela est inÃ©vitable lorsque les agrÃ©gats sont trop gros et que lâ€™on veut y accÃ©der en Ã©criture. Donc, gardons les atomiques ! Coeur: Lâ€™une des (nombreuses) brillantes idÃ©es de ce projet a Ã©tÃ© de suivre le prÃ©cepte de â€œFunctional Core/ Imperative Shellâ€, introduit en 2012 dans la communautÃ© Ruby, puis repris plus rÃ©cemment par Kenneth Lange et aussi par Thoman Pierrain &amp; Bruno BOUCARD ; Cette approche a dâ€™Ã©normes avantages, citons-en 2 :  dâ€™abord repousser les effets de bord (les fameux, ceux qui rendent vos tests trop compliquÃ©s, plus du tout isolÃ©s, voire inconsistants et cachent de nombreux bugs) en dehors des considÃ©rations mÃ©tier.  corollaire : cela vous permet de vous concentrer sur la seule logique mÃ©tier de maniÃ¨re fonctionnelle, câ€™est-Ã -dire en privilÃ©giant lâ€™immutabilitÃ© et la transparence rÃ©fÃ©rentielle. Cette faÃ§on de penser le logiciel en y plaÃ§ant un cÅ“ur purement fonctionnel (dans les 2 sens du terme) permet dâ€™isoler vraiment les tests mÃ©tiers et donc de se passer entiÃ¨rement des mocks Ã  cet endroit. Dans le cÅ“ur mÃ©tier propre du Messager sont Ã©galement apparues dâ€™autres frontiÃ¨res, et donc dâ€™autres Bounded Context pour des composants qui avaient besoin de pouvoir Ã©voluer sans casser les autres. Tout ce travail dâ€™isolation (via des ACL, anti corruption layers) est primordial pour ne pas sâ€™enfermer dans une complexitÃ© accidentelle et dans ce qui devient inexorablement, malgrÃ© toute bonne volontÃ©, une â€œbig ball of mudâ€ (grosse boule de boue). Hexagone: Il y a le cÅ“ur fonctionnel, et il y a la coquille (shell en Anglais). Câ€™est ce que lâ€™on retrouve aussi dans les architectures hexagonales (ou Clean Architecture). Dans la partie coquille (hors cÅ“ur mÃ©tier donc) on va retrouver les ports et adaptateurs. Câ€™est cette philosophie que nous avons appliquÃ©e fortement. Et nous avons fabriquÃ© des adaptateurs techniques pour toute situation spÃ©cifique. Lâ€™absorption de commandes venues dâ€™une API REST est un adaptateur indÃ©pendant. Il a une dÃ©pendance directe avec les objets mÃ©tiers. Par contre pour toute opÃ©ration en base de donnÃ©es (nous avons, en prÃ©vision dâ€™un CQRS sÃ©parÃ© les opÃ©rations de lecture et celles dâ€™Ã©criture), il y a des adaptateurs dÃ©diÃ©s. Il en va de mÃªme pour les opÃ©rations dâ€™envoi et de rÃ©ception de messages dans un bus (afin de prÃ©venir les agents dans dâ€™autres Bounded Contexts quâ€™un Ã©vÃ©nement important sâ€™est passÃ© dans notre domaine. QualitÃ©: TDD offre ce double avantage dâ€™Ãªtre la mÃ©thode dâ€™Ã©criture du logiciel (et non de test) qui nous a permis de faire du design Ã©mergent guidÃ© par le DDD tactique et de toujours se fixer des petits pas. Et bien sÃ»r, on obtient une couverture de tests trÃ¨s satisfaisante, puisquâ€™aucune ligne de code ne devrait Ãªtre Ã©crite si elle nâ€™est pas justifiÃ©e par un test. Kotlin (encore lui !) vient avec une gÃ©niale librairie : Kotest. Attention Ã  ne pas faire comme moi au dÃ©but, de faire la confusion entre KotlinTest et Kotest. Câ€™est bien Kotest qui permet de choisir parmi moult styles de tests, il y en a vraiment pour tout le monde : style Behaviour Driven Development (celui que nous avons choisi), style Scala, Ruby, Cucumber ou JavaScript/TypeScript. Ou ce bon vieux JUnit. Ã‰crire des tests, câ€™est bien joli, mais encore faut-il sâ€™assurer quâ€™ils servent Ã  quelque chose et quâ€™ils sont robustes. Les outils dÃ©jÃ  en place pour les autres projets Java de lâ€™entreprise (Jenkins, SonarQube, un scanner de vulnÃ©rabilitÃ© des dÃ©pendances) se sont parfaitement intÃ©grÃ©s Ã  notre nouveau projet Kotlin. La Couverture de code a pu donc Ãªtre constamment mesurÃ©e, mais jâ€™en dirai plus au prochain chapitre. Dâ€™autres outils sont venus renforcer cette recherche de qualitÃ© :  ArchUnit, pour vÃ©rifier en permanence le bon usage des dÃ©pendances et vÃ©rifier que nous ne cassions pas les principes de lâ€™architecture hexagonale.  Gatling pour sâ€™assurer que notre solution tient la charge en situation rÃ©elleRigueur: Un grand enjeu de la qualitÃ© logicielle semble Ãªtre la couverture de code, mais cette mesure peut sâ€™avÃ©rer erronÃ©e, comme je le prouve dans ma prÃ©sentation sur les tests par mutation de code. Dans ce projet, il nous a paru opportun de consolider notre approche TDD, parce quâ€™aprÃ¨s tout nous sommes tous faillibles, et quâ€™un outil qui nous montre que nous manquons de tests, que des bugs sont encore prÃ©sents, est tout simplement une aubaine. Nous avons choisi la lib PiTest, qui fonctionne sur le ByteCode Java, et donc trÃ¨s bien avec Kotlin. Simple dâ€™usage, facile Ã  ajouter Ã  un pipeline dâ€™intÃ©gration continue, cet outil va nous aider Ã  mieux coder et mieux tester (lâ€™un ne va pas sans lâ€™autre). Il nous a rappelÃ© sans faillir aux rÃ¨gles du TDD (ne pas Ã©crire une instruction qui ne soit justifiÃ©e par un test). Par contre, il est avisÃ© dâ€™utiliser ce genre dâ€™outil sur du nouveau code plutÃ´t que sur du legacy, et de cibler du code purement mÃ©tier, câ€™est-Ã -dire au centre (functional core) de lâ€™architecture hexagonale. Paradigme (changement de): Ce nâ€™est pas chose facile que de bousculer (un peu) les habitudes des dÃ©veloppeurs. Alors que la programmation orientÃ©e objet est maÃ®trisÃ©e par tous mes collÃ¨gues, je leur ai fait la proposition de parier sur lâ€™immutabilitÃ©. Lâ€™immutabilitÃ©, câ€™est quoi ? Une idÃ©e qui nous vient de la programmation fonctionnelle mais qui sâ€™applique trÃ¨s bien Ã  la POO. Le principe est simple : quand les objets ne â€œmutentâ€ pas (comprendre : ne changent pas dâ€™Ã©tat) alors ils sont plus facile Ã  maÃ®triser, Ã  comprendre et surtout on Ã©vite beaucoup, beaucoup de bugs car on limite grandement les effets de bord dans les mÃ©thodes de ces objets immuables. Mieux encore, cette immutabilitÃ© est facile Ã  obtenir avec des langages tels que Kotlin (celui que nous avons choisi pour ce projet) ou mÃªme Java (le mot clÃ© final existe et il a Ã©tÃ© ensuite complÃ©tÃ© avec des librairies qui poussent une vraie immutabilitÃ© des objets, comme par exemple https://www. baeldung. com/immutables). Elle permet de transitionner naturellement vers une Ã©criture de code plus â€œfonctionnelleâ€ câ€™est-Ã -dire avec une meilleur rÃ©partition des responsabilitÃ©s (voir chapitre suivant), et une plus grande intÃ©gritÃ© rÃ©fÃ©rentielle. Solide: Notre attention sâ€™est focalisÃ©e sur la production dâ€™ un code SOLID. Ce nâ€™est pas facile de vous parler des principes dâ€™un code SOLID, surtout que cela fait partie de la grande famille du code â€œpropreâ€ (Clean Code). Le premier principe est peut Ãªtre le plus important et le plus simple Ã  comprendre : Simple Responsibility. Et tous les autres en dÃ©coulent. Nous avons toujours cherchÃ© dans ce projet Ã  exprimer et rÃ©partir les responsabilitÃ©s de faÃ§on trÃ¨s claire et trÃ¨s cohÃ©rente entre les diffÃ©rents modules. Que ce soit dans le dÃ©coupage mÃ©tier (Bounded Contexts, DDD StratÃ©gique) ou dans lâ€™approche technique (Archi HÃ©xagonale DDD Tactique), notre objectif a tout le temps Ã©tÃ© de limiter la responsabilitÃ© Ã  un niveau minimal et acceptable, afin de mieux sÃ©parer et isoler ces responsabilitÃ©s. Les cartes CRC nous ont aussi beaucoup aidÃ© Ã  y voir plus clair dans notre design. DÃ©couplÃ©: Le dÃ©couplage est un fondamental Ã  la fois de lâ€™architecture dâ€™un logiciel mais aussi de la journÃ©e ordinaire dâ€™un dÃ©veloppeur. Il sâ€™agit simplement de ne pas accumuler la complexitÃ© et les interactions douteuses qui peuvent se loger dans le code. Pour cela nous avons fait le choix dâ€™abstractions pour dÃ©finir et maÃ®triser ces fameuses dÃ©pendances. Lâ€™idÃ©e est dâ€™exprimer simplement les choses en termes de â€œquoiâ€ et non de â€œcommentâ€. Exemple : au lieu de dire Ã  notre code â€œje veux une base de donnÃ©es Mongo pour stocker des informationsâ€, nous avons Ã©tabli une abstraction (interface) qui dit â€œje veux pouvoir stocker cette informationâ€. Le â€œcommentâ€ ne nous intÃ©resse absolument pas. En se rÃ©fÃ©rant Ã  cette abstraction (â€œJe_veux_stocker_information_Xâ€), nous voilÃ  libres de son implÃ©mentation. Et câ€™est double bÃ©nÃ©fice. Dâ€™abord nous pouvons choisir librement lâ€™implÃ©mentation et en changer Ã  tout moment au cours de la vie du projet (nous avons choisi Mongo DB mais peut Ãªtre que ce choix sera remis en cause). Et surtout, pendant les tests fonctionnels, nous nâ€™avons pas lâ€™obligation de mettre en route la fameuse base de donnÃ©es Mongo que nous avons choisie pour la production. Nous pouvons juste utiliser un fake, câ€™est-Ã -dire une implÃ©mentation naÃ¯ve, simpliste. Evenementiel: Une autre grande force de ce projet est que nous avons dâ€™emblÃ©e pris en compte la nature Ã©vÃ©nementielle dâ€™une application. Dans un logiciel, il se passe des choses. Il est plus important de capturer des Ã©vÃ¨nements que dâ€™enregistrer lâ€™Ã©tat des objets. Malheureusement, trop dâ€™applications sont dÃ©veloppÃ©es en mode CRUD (Create Read Update Delete), aidÃ©es (mais pas dans le bon sens) par les frameworks de mapping ORM. Ce mode de dÃ©veloppement rend compliquÃ© toute migration fonctionnelle, car justement il est difficile de placer des rÃ¨gles mÃ©tiers quand on pense que tout se limite Ã  des opÃ©rations dâ€™ajout/modification/suppression/lecture en base de donnÃ©es. En pensant Ã©vÃ©nements, on est au contraire ouvert Ã  tout ce qui peut se passer comme vÃ©rifications, contraintes, Ã©volution du mÃ©tier. On est bien plus proche des actions des utilisateurs. On peut crÃ©er des programmes plus aptes Ã  rÃ©pondre au besoin mÃ©tier, et moins coincÃ© dans une solution technique. En pratique, nos agrÃ©gats mÃ©tiers Ã©mettent des Ã©vÃ©nements, en rÃ©action Ã  des commandes, aprÃ¨s avoir opÃ©rÃ© les vÃ©rifications mÃ©tier qui sâ€™imposent. Nous avons mis en place un mÃ©canisme de remontÃ©e automatique des Ã©vÃ©nements (event bubbling) depuis les entitÃ©s filles qui composent un agrÃ©gat global (grÃ¢ce Ã  ReactiveX et ses Observables). Partage: Cela a Ã©tÃ© une discussion intÃ©ressante (parmi tant dâ€™autres) : Comment sâ€™y prendre pour se partager le travail et le partager avec les autres ? Bien sÃ»r il y a lâ€™usage de lâ€™attirail Jira, Git, Jenkinsâ€¦ Mais ce qui importe câ€™est surtout la faÃ§on dont on sâ€™en sert. Nous avons optÃ© pour des ADR dans les points clÃ© de notre repository, afin de garder trace de nos discussions et de remettre en contexte les choix tactiques opÃ©rÃ©s dans le code. Nous avons aussi mis lâ€™accent sur le pair programming. Mais nous avions quand mÃªme voulu garder les Code Reviews, pour prendre de la hauteur sur le code produit (essentiellement par Damien BouÃ© et moi mÃªme). Je suis plus partisan du Trunk Based Development, mais en adoptant des tests plus longs Ã  exÃ©cuter comme le Mutation Testing, il Ã©tait intÃ©ressant dâ€™isoler tout nouveau code dans une branche dÃ©diÃ©e afin de voir sâ€™exÃ©cuter correctement toute la lignÃ©e de tests, sans compromettre la branche principale (on aurait pu faire du TCR mais câ€™est un peu violent). Nous avons plutÃ´t optÃ© pour des Short Lived Branch avec des rÃ¨gles du jeu : pas plus de 2 branches diffÃ©rentes en simultanÃ© et ne portant pas sur les mÃªmes â€œzonesâ€ du code. Au bout dâ€™un moment, nous avions assez dâ€™abstractions (branching by abstraction) pour Ã©viter des â€œrebaseâ€ douloureux. Bien sÃ»r, quand nous avions Ã  faire des refactoring qui touchaient plusieurs endroits du code, il fallait dâ€™abord solder toutes les branches en cours, avant de sâ€™attaquer Ã  des modifications qui auraient eu trop dâ€™impacts sur lâ€™architecture ou les interfaces fondatrices. Pour Ã©viter que les refactoring ne durent trop longtemps et ne conduisent Ã  des rÃ©conciliations de code houleuses, jâ€™ai recommandÃ© dâ€™adopter la mÃ©thode Mikado, afin, une fois de plus, de progresser par petits pas, de merger trÃ¨s trÃ¨s souvent, de ne pas se lancer dans des travaux dâ€™Hercule, et de se rendre compte des problÃ¨mes au plus tÃ´t. Le refactoring devient Ã©galement plus aisÃ© en adoptant la mÃ©thode â€œparallel changeâ€ ou â€œexpand and contractâ€ : on ne casse pas lâ€™existant; on implÃ©mente dans une nouvelle mÃ©thode ce qui doit Ãªtre refactorÃ©, et petit Ã  petit on transite vers le nouveau code, avant dâ€™effacer lâ€™ancien quand il nâ€™est plus utilisÃ© nulle part. Encore une fois, lâ€™architecture hexagonale, avec son dÃ©couplage maximum, nous a permis de minimiser la casse. Je suis trÃ¨s content dâ€™avoir travaillÃ© comme cela, car les revues de code nous ont permis de se poser la question â€œest ce que notre design reste cohÃ©rentâ€ Ã  chaque Ã©tape de la construction du logiciel. AgilitÃ©: Il Ã©tait important dâ€™avoir du feedback rapide mÃªme sur un produit qui nâ€™est pas encore mis en exploitation. Nous avons optÃ© pour un travail en flux type Kanban, avec des jalons variables qui Ã©taient matÃ©rialisÃ©s par des Minor Releases, selon nos dÃ©sidÃ©rata et contraintes. Nous avons pu compter sur une IntÃ©gration Continue (CI/CD) super efficace grÃ¢ce au soutien de lâ€™Ã©quipe DevOps en place. RÃ©sultat: Le projet nâ€™est pas encore terminÃ©, et vous nâ€™en verrez pas une dÃ©monstration graphique, car ce nâ€™est quâ€™un composant au milieu de tant dâ€™autres. Mais comme il va devenir un maillon fort de lâ€™Ã©difice logiciel de Primobox, câ€™est la fiabilitÃ©, la rapiditÃ© et la performance de produits qui vont sâ€™en trouver renforcÃ©es. Ainsi que la maÃ®trise technique des Ã©quipes R&amp;D. Exemplaire: Ce qui est dâ€™emblÃ©e visible ce sont les mÃ©triques dâ€™un code de qualitÃ©, tel que peut nous les montrer Sonarqube. Et pour moi câ€™est une grande fiertÃ© dâ€™avoir contribuÃ© Ã  ce projet.  Notes: Discret au sens mathÃ©matique du terme : qui est clairement dÃ©limitÃ©, sÃ©parÃ©, isolÃ©.       &#8617;    "
    }, {
    "id": 5,
    "url": "http://0.0.0.0:4000/outside-in-tdd-diamond/",
    "title": "L'Outside-in Diamond TDD, ou l'art de mieux tester",
    "body": "2022/01/15 -  Image dâ€™illustration : Copyright 42skillz / Thomas PIERRAIN Le besoin: DÃ©velopper de bons tests unitaires nâ€™est pas une tÃ¢che aisÃ©e. MÃªme les dÃ©veloppeurs les plus expÃ©rimentÃ©s peuvent tomber dans les piÃ¨ges â€œclassiquesâ€ de la pratique du dÃ©veloppement des tests automatisÃ©s. Les plus courants sont :  Les tests fragiles : ce que lâ€™on teste dans ceux-ci est souvent lâ€™implÃ©mentation, dÃ» Ã  lâ€™utilisation excessive de mocks. Lors dâ€™un refactoring, ils devront Ãªtre mis Ã  jour systÃ©matiquement et ce sera coÃ»teux.  Les tests â€œinutilesâ€ : ce sont des tests qui couvrent du code trivial, et qui nâ€™apportent pas de plus-value au projet. Ce sont des tests qui ne sont pas orientÃ©s mÃ©tier. Par exemple : un test qui va tester une classe de mapping.  Les tests trop complexes : ceux-ci sont souvent des tests dâ€™intÃ©gration qui nÃ©cessitent beaucoup de plomberie (liÃ©e aux prÃ©requis) que lâ€™on ne voit pas. De ce fait, ils deviennent rapidement trÃ¨s difficiles Ã  maintenir. Ils sont souvent trÃ¨s lents Ã  exÃ©cuter, difficiles Ã  comprendre et portent sur du code complexe avec de nombreuses lignes de code. Mais alors, comment peut-on rÃ©aliser des tests plus robustes ? Pour cela, laissez-moi vous prÃ©senter lâ€™Outside-in Diamond TDD. Quâ€™est ce que lâ€™Outside-in Diamond TDD ?: Lâ€™Outside-in Diamond TDD est une technique dâ€™approche des tests unitaires mise au point par Thomas Pierrain. Lâ€™idÃ©e de base est nÃ©e dâ€™une constatation : la notion de tests unitaires est mal comprise par la majoritÃ© des dÃ©veloppeurs. En effet, ceux-ci pensent quâ€™un test unitaire est un bout de code qui va tester un petit composant en isolation des autres. Or, comme le fait si bien remarquer Thomas Pierrain, la dÃ©finition de Kent Beck est beaucoup plus juste :  Tests that â€œruns in isolationâ€ from other tests (des tests qui sâ€™exÃ©cutent en isolation des autres tests) Un bon test unitaire sâ€™isole donc lui-mÃªme des autres tests, il nâ€™isole pas le composant quâ€™il teste des autres composants. Cela veut dire que lâ€™on peut faire des tests unitaires qui ne testent pas quâ€™une classe. Ce nâ€™est pas tout : un bon test unitaire sâ€™isole avant tout des dÃ©pendances externes (base de donnÃ©es, disque, API externeâ€¦). De plus, Thomas Pierrain a constatÃ© que la pyramide des tests est souvent utilisÃ©e de maniÃ¨re dogmatique sans que les dÃ©veloppeurs ne se posent la question de ce qui est pertinent Ã  tester. Pendant longtemps, il a cherchÃ© Ã  lutter pour faire oublier ces fausses idÃ©es, sans succÃ¨s. Jâ€™aime bien sa rÃ©fÃ©rence Ã  la loi dâ€™Alberto Brandolini Ã  propos de ce sujet :  â€œThe amount of energy needed to refute bullshit is an order of magnitude larger than to produce itâ€ Donc plutÃ´t que de lutter inutilement pour faire admettre ces idÃ©es, Thomas Pierrain est parti sur lâ€™idÃ©e de promouvoir les tests dâ€™acceptation. En effet, ceux-ci sont plus faciles Ã  faire accepter pour voir le systÃ¨me Ã  tester comme une boÃ®te noire. Les dÃ©veloppeurs auront alors plutÃ´t tendance Ã  tester en termes de contrat mÃ©tier, ce qui est plus sain pour la maintenabilitÃ© des projets. Outside-in: La notion dâ€™Outside-in TDD est assez simple Ã  comprendre : on teste de lâ€™extÃ©rieur en allant vers lâ€™intÃ©rieur. On commence donc par Ã©crire des tests dâ€™acceptation â€œgros grainsâ€ qui sont orientÃ©s mÃ©tier et testent le systÃ¨me en boÃ®te noire. Pendant la phase red de TDD portant sur ces tests gros grains, on peut Ãªtre amenÃ© Ã  rÃ©aliser des boucles TDD plus petites sur lâ€™intÃ©rieur du systÃ¨me, typiquement sur le modÃ¨le du domaine. A la fin, une fois toutes ces petites boucles rÃ©alisÃ©es, la boucle principale â€œgros grainâ€ deviendra alors passante. Diamond: La notion de Diamond vient du fait que les tests rÃ©alisÃ©s changent complÃ¨tement la pyramide de test telle que nous la connaissons. Le diamant est fait pour symboliser lâ€™importance et la prÃ©pondÃ©rance de ces tests dâ€™acceptation par rapport aux autres types de tests (cf. image en haut de lâ€™article) : tests unitaires, tests dâ€™intÃ©gration, tests end-to-end. Ce style de TDD nous oriente donc Ã  Ã©crire plus de tests haut niveau et moins de tests dans le dÃ©tail. Pourquoi lâ€™Outside-in Diamond TDD est si intÃ©ressant ?: Cela fait quelques annÃ©es maintenant que jâ€™utilise lâ€™architecture hexagonale dans mes projets en production. Jâ€™ai toujours privilÃ©giÃ© les tests unitaires au niveau de mon modÃ¨le de domaine, en les construisant Ã  partir des diffÃ©rents cas manipulÃ©s par mes services applicatifs. Le schÃ©ma ci-dessous reprÃ©sente en vert la partie couverte par les tests unitaires tels que je les rÃ©alisais : Cela pose un problÃ¨me majeur. Il y a tout une partie de code qui se retrouve non testÃ©e : les adaptateurs de gauche (API REST par exemple) et les adaptateurs de droite (base de donnÃ©es par exemple). Ces parties sont matÃ©rialisÃ©es en jaune sur le schÃ©ma. Bien sÃ»r, ils Ã©taient couverts par les tests dâ€™intÃ©gration, mais les tests dâ€™intÃ©gration sont lents. Thomas Pierrain nous fait le retour dâ€™expÃ©rience suivant : la plupart des bugs subtils proviennent de ce code non testÃ©, prÃ©sent dans les adaptateurs. Il prÃ©conise donc de tester tout l'hexagone, en partant des adaptateurs de gauche, ainsi quâ€™en incluant les adaptateurs de droite (en mockant ou fakant uniquement les I/O, que ce soit de la base de donnÃ©es, du fichier ou du rÃ©seau). Câ€™est lÃ  tout lâ€™intÃ©rÃªt de ce pattern de tests : on a des tests Ã  la fois rapides et qui couvrent largement notre base de code. On a alors un code couvert comme cela : Voyons maintenant un exemple de code pour ces tests (gestion de panier sur un site de e-commerce) : 400: Invalid requestConclusion: Finalement, quâ€™est ce que câ€™est quâ€™un â€œbonâ€ test unitaire ? Il existe autant de dÃ©finitions dâ€™un bon test quâ€™il existe de dÃ©veloppeurs. Pour moi, un bon test unitaire est un test qui va tester un contrat mÃ©tier, sans se prÃ©occuper de lâ€™implÃ©mentation. De cette maniÃ¨re, il pourra survivre Ã  tous les refactorings. Mais ce nâ€™est pas tout. Un bon test unitaire doit Ãªtre parlant. Il doit Ãªtre concis. Malheureusement, le code des tests unitaires est souvent considÃ©rÃ© comme moins important que le code de production et câ€™est une erreur. Il faut quâ€™il soit traitÃ© avec la plus grande attention. Je vais mÃªme aller plus loin : si un test est bien Ã©crit, il sera la documentation de votre use case que vous nâ€™Ã©crirez jamais. Personnellement, jâ€™aime bien lâ€™approche proposÃ©e par Vladimir Khorikov pour dÃ©finir la valeur dâ€™un test. Pour lui, les 4 piliers fondamentaux dâ€™un bon test sont :  quâ€™il doit permettre dâ€™intercepter une rÃ©gression quâ€™il doit rÃ©sister aux refactorings (grÃ¢ce au fait quâ€™il ne soit pas liÃ© Ã  lâ€™implÃ©mentation du systÃ¨me testÃ©) quâ€™il doit fournir un feedback trÃ¨s rapide quâ€™il doit avoir un coÃ»t de maintenance faibleJe trouve que les tests rÃ©alisÃ©s en Outside-in Diamond TDD remplissent trÃ¨s bien ces fonctions :  ils interceptent bien les rÃ©gressions car ce sont des tests dâ€™acceptation orientÃ©s mÃ©tier qui testent du comportement. Si celui-ci change, alors on le sait immÃ©diatement.  ils rÃ©sistent au refactoring car on teste en boÃ®te noire lâ€™hexagone complet en partant des adaptateurs de gauche ils sont rapides, car on utilise le moins de frameworks possible et on mock les I/O (BDD, systÃ¨me de fichiers, rÃ©seauâ€¦) ils ont un coÃ»t de maintenance faible de par leur nature â€œmÃ©tierâ€Un autre avantage indÃ©niable que je trouve Ã  ce pattern de TDD : il permet dâ€™Ã©crire moins de tests et mieux. Chez Primobox, nous mettons en place ce pattern de tests afin de pÃ©renniser nos projets sur le long terme. Sources :  Outside-in Diamond ğŸ”· TDD #1 - a style made from (&amp; for) ordinary people Outside-in Diamond ğŸ”· TDD #2 (anatomy of a style) Tech Lead Journal #58 - Principles for Writing Valuable Unit Tests - Vladimir Khorikov"
    }];

var idx = lunr(function () {
    this.ref('id')
    this.field('title')
    this.field('body')

    documents.forEach(function (doc) {
        this.add(doc)
    }, this)
});
function lunr_search(term) {
    document.getElementById('lunrsearchresults').innerHTML = '<ul></ul>';
    if(term) {
        document.getElementById('lunrsearchresults').innerHTML = "<p>R&eacute;sultats de recherche pour '" + term + "'</p>" + document.getElementById('lunrsearchresults').innerHTML;
        //put results on the screen.
        var results = idx.search(term);
        if(results.length>0){
            for (var i = 0; i < results.length; i++) {
                // more statements
                var ref = results[i]['ref'];
                var url = documents[ref]['url'];
                var title = documents[ref]['title'];
                var body = documents[ref]['body'].substring(0,160)+'...';
                document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML + "<li class='lunrsearchresult'><a href='" + url + "'><span class='title'>" + title + "</span><br /><span class='body'>"+ body +"</span><br /><span class='url'>"+ url +"</span></a></li>";
            }
        } else {
            document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = "<li class='lunrsearchresult'>Pas de r&eacute;sultats...</li>";
        }
    }
    return false;
}

function lunr_search(term) {
    $('#lunrsearchresults').show( 400 );
    $( "body" ).addClass( "modal-open" );
    
    document.getElementById('lunrsearchresults').innerHTML = '<div id="resultsmodal" class="modal fade show d-block"  tabindex="-1" role="dialog" aria-labelledby="resultsmodal"> <div class="modal-dialog shadow-lg" role="document"> <div class="modal-content"> <div class="modal-header" id="modtit"> <button type="button" class="close" id="btnx" data-dismiss="modal" aria-label="Fermer"> &times; </button> </div> <div class="modal-body"> <ul class="mb-0"> </ul>    </div> <div class="modal-footer"><button id="btnx" type="button" class="btn btn-danger btn-sm" data-dismiss="modal">Fermer</button></div></div> </div></div>';
    if(term) {
        document.getElementById('modtit').innerHTML = "<h5 class='modal-title'>R&eacute;sultats de recherche pour '" + term + "'</h5>" + document.getElementById('modtit').innerHTML;
        //put results on the screen.
        var results = idx.search(term);
        if(results.length>0){
            //console.log(idx.search(term));
            //if results
            for (var i = 0; i < results.length; i++) {
                // more statements
                var ref = results[i]['ref'];
                var url = documents[ref]['url'];
                var title = documents[ref]['title'];
                var body = documents[ref]['body'].substring(0,160)+'...';
                document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML + "<li class='lunrsearchresult'><a href='" + url + "'><span class='title'>" + title + "</span><br /><small><span class='body'>"+ body +"</span><br /><span class='url'>"+ url +"</span></small></a></li>";
            }
        } else {
            document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = "<li class='lunrsearchresult'>D&eacute;sol&eacute;, pas de r&eacute;sultats trouv&eacute;s. Fermez et essayez une recherche diff&eacute;rente !</li>";
        }
    }
    return false;
}
    
$(function() {
    $("#lunrsearchresults").on('click', '#btnx', function () {
        $('#lunrsearchresults').hide( 5 );
        $( "body" ).removeClass( "modal-open" );
    });
});