<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tech Blog</title>
    <description>Innover, Partager, Grandir ensemble</description>
    <link>http://0.0.0.0:4000/</link>
    <atom:link href="http://0.0.0.0:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 23 Feb 2022 05:29:38 -0600</pubDate>
    <lastBuildDate>Wed, 23 Feb 2022 05:29:38 -0600</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>Le â€œMessagerâ€ : un projet pas comme les autres chez Primobox</title>
        <description>&lt;p&gt;Trouver une entreprise dans laquelle on peut progresser, apprendre, innover, tout en forgeant un logiciel de qualitÃ© et des compÃ©tences partageables Ã  tout le monde, nâ€™est pas chose courante.&lt;/p&gt;

&lt;p&gt;Primobox est de cette trempe lÃ .&lt;/p&gt;

&lt;p&gt;Laissez-moi vous raconter briÃ¨vement cette aventure que jâ€™ai eu la chance de vivre.&lt;/p&gt;

&lt;h2 id=&quot;genÃ¨se&quot;&gt;GenÃ¨se&lt;/h2&gt;

&lt;p&gt;Vous connaissez lâ€™adage â€œDiviser pour mieux rÃ©gnerâ€ ? Câ€™est ce que nous invite Ã  faire lâ€™approche DDD (Domain Driven Design). Et câ€™est avec ce principe en tÃªte (dÃ©limiter des Contextes Explicites et &lt;a href=&quot;https://fr.wikipedia.org/wiki/Topologie_discr%C3%A8te&quot;&gt;Discrets&lt;/a&gt; &lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;) quâ€™un projet de Messager autonome est nÃ© chez Primobox (pour faire simple, le Messager est celui chargÃ© de remettre le courrier Ã  ses destinataires).&lt;/p&gt;

&lt;p&gt;DotÃ© dâ€™une grande responsabilitÃ©, simple au premier abord mais qui permet dâ€™envisager des options et des possibilitÃ©s multiples, en toute autonomie.&lt;/p&gt;

&lt;p&gt;Une fois ce domaine (contexte) mÃ©tier spÃ©cifique identifiÃ© , parmi les autres besoins clients que doivent satisfaire les solutions proposÃ©es par Primobox, il Ã©tait plus facile de lancer un chantier ciblÃ© de modernisation du code.&lt;/p&gt;

&lt;p&gt;Avec un pÃ©rimÃ¨tre et des relations bien dÃ©finis, ce vÃ©ritable â€œmÃ©tier dans le mÃ©tierâ€ allait pouvoir prendre son envol.&lt;/p&gt;

&lt;h2 id=&quot;vision&quot;&gt;Vision&lt;/h2&gt;

&lt;p&gt;Un projet rÃ©ussi commence par une vision. &lt;a href=&quot;https://www.linkedin.com/in/alexandre-fillatre-696643168/&quot;&gt;Alexandre Fillatre&lt;/a&gt;, CTO chez Primobox a su initier et nourrir cette vision. BasÃ©e sur une idÃ©e simple : les diffÃ©rentes phases qui composent lâ€™activitÃ© de lâ€™offre de service chez Primobox (dÃ©matÃ©rialisation de la relation entre employÃ©s et employeurs) ont chacune une raison dâ€™exister propre, tout en Ã©tant capable dâ€™interagir avec les autres parties et dâ€™Ã©voluer de maniÃ¨re autonome. Alexandre nous a partagÃ© cette vision et nous a fait confiance pour la mettre en Å“uvre.&lt;/p&gt;

&lt;h2 id=&quot;utilisateurs&quot;&gt;Utilisateurs&lt;/h2&gt;

&lt;p&gt;En amont, un vrai travail pour comprendre le besoin utilisateur avait Ã©tÃ© initiÃ© et je lâ€™ai traduit en Ã©lÃ©ments que nous allions mettre dans le cÅ“ur du â€œMessagerâ€.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://stephaniewalter.design/fr/blog/introduction-aux-user-journey-maps-modeles-pdf-a-telecharger/&quot;&gt;Lâ€™atelier de Wording et les User Journeys&lt;/a&gt; mâ€™ont Ã©tÃ© trÃ¨s utiles pour cerner le domaine mÃ©tier dans son ensemble et dans ses particularitÃ©s.&lt;/p&gt;

&lt;h2 id=&quot;clartÃ©&quot;&gt;ClartÃ©&lt;/h2&gt;

&lt;p&gt;La clartÃ© se gagne par lâ€™analyse. GrÃ¢ce aux travaux prÃ©liminaires de lâ€™Ã©quipe Produit et Ergonomie, jâ€™ai pu coucher sur le papier une carte (Ã  la Wardley) des interactions entre le Messager et les autres Ã©lÃ©ments qui constituent la solution globale dont nos clients ont besoin.&lt;/p&gt;

&lt;p&gt;Cela permet de savoir quelles fonctionnalitÃ©s sont plus importantes, lesquelles sont annexes, lesquelles sont laissÃ©es Ã  la responsabilitÃ© dâ€™autres modules (existants ou Ã  crÃ©er) voire externalisÃ©es.&lt;/p&gt;

&lt;p&gt;Des choix stratÃ©giques importants sur le pÃ©rimÃ¨tre fonctionnel ont Ã©tÃ© faits afin de rÃ©duire la charge de travail et la complexitÃ© prÃ©sente sur certains produits.&lt;/p&gt;

&lt;p&gt;Cela dessine une forme dâ€™architecture, plus basÃ©e sur les besoins que la technique.&lt;/p&gt;

&lt;p&gt;Cela nous libÃ¨re aussi des dÃ©tails techniques, car sur un &lt;a href=&quot;https://github.com/ddd-crew/context-mapping&quot;&gt;Context Mapping&lt;/a&gt; (toujours cette notion de cartographie) se dessinent les frontiÃ¨res entre les &lt;a href=&quot;https://martinfowler.com/bliki/BoundedContext.html&quot;&gt;Bounded Contexts&lt;/a&gt;; et lâ€™on voit facilement les choix contraints par lâ€™existant (legacy), et par ailleurs les espaces oÃ¹ les contraintes changent de nature. Par exemple, lÃ  oÃ¹ la performance est plus importante que la compatibilitÃ©.&lt;/p&gt;

&lt;h2 id=&quot;audace&quot;&gt;Audace&lt;/h2&gt;

&lt;p&gt;Prendre des paris audacieux, aprÃ¨s tout, pourquoi pas ? Pourquoi rester conforme Ã  ce qui a Ã©tÃ© fait par le passÃ© et se priver de progresser ?&lt;/p&gt;

&lt;p&gt;Parlons du langage de dÃ©veloppement. Primobox a un historique Java solidement ancrÃ©.&lt;/p&gt;

&lt;p&gt;Moi jâ€™arrivais du monde .Net.&lt;/p&gt;

&lt;p&gt;Alexandre Fillatre a su discerner quâ€™un bon dÃ©veloppeur ne saurait sâ€™arrÃªter Ã  une syntaxe donnÃ©e, lâ€™essentiel Ã©tant ce que lâ€™on sait obtenir de tel ou tel langage de dÃ©veloppement.&lt;/p&gt;

&lt;p&gt;La POO est une chose universelle mais les langages modernes Ã©voluent pour Ãªtre plus hydrides et flirtent plus facilement avec la Programmation Fonctionnelle. Câ€™est le cas de C#, puis de Java qui lui a emboÃ®tÃ© le pas.&lt;/p&gt;

&lt;p&gt;Quitte Ã  sâ€™Ã©loigner de C# 9 pour aborder la JVM, autant opter pour un langage du mÃªme niveau.&lt;/p&gt;

&lt;p&gt;Câ€™est lÃ  que nous avons pensÃ© Ã  â€¦ Kotlin !&lt;/p&gt;

&lt;p&gt;Etant pour ma part un adepte prÃ©coce de C# et de lâ€™Ã©cosystÃ¨me .Net, je nâ€™avais jamais eu Ã  me frotter au monde Java ailleurs que dans mes Ã©tudes. GrÃ¢ce Ã  Kotlin, franchir le cap a Ã©tÃ© pour moi dâ€™une facilitÃ© dÃ©concertante.&lt;/p&gt;

&lt;p&gt;Jâ€™ai retrouvÃ© tous mes rÃ©flexes acquis en C# avec une syntaxe encore plus Ã©lÃ©gante. Ayant lâ€™habitude de Linq, Kotlin est naturellement provisionnÃ© pour faire la mÃªme chose. En mieux ! Et il est facile de trouver de &lt;a href=&quot;https://kotlinlang.org/docs/collection-operations.html#common-operations&quot;&gt;lâ€™aide&lt;/a&gt; et des &lt;a href=&quot;https://github.com/mythz/kotlin-linq-examples&quot;&gt;exemples&lt;/a&gt;. Et des trÃ¨s bons &lt;a href=&quot;https://www.baeldung.com/kotlin/&quot;&gt;tutos&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;arriÃ¨re-boutique&quot;&gt;ArriÃ¨re boutique&lt;/h2&gt;

&lt;p&gt;Ah oui, si vous cherchez des ressources sur Kotlin dans les Internets, vous verrez que ce langage est la panacÃ©e pour les applications mobiles. Et pourtant ! Câ€™est excessivement rÃ©ducteur.&lt;/p&gt;

&lt;p&gt;Kotlin produit (aussi) du bytecode qui va tourner sur la JVM. Donc câ€™est un parfait candidat pour tout le code backend. Câ€™est ce que nous avons fait pour cette application complexe, avec une architecture trÃ¨s Ã©voluÃ©e, ce qui nous a permis dâ€™Ãªtre parfaitement intÃ©grÃ© dans lâ€™existant Java et surtout trÃ¨s performant.&lt;/p&gt;

&lt;h2 id=&quot;idiomes&quot;&gt;Idiomes&lt;/h2&gt;

&lt;p&gt;Quitte Ã  choisir un langage qui nous Ã©tait inconnu (Ã  moi et mon coreligionnaire, pur Javaiste pour sa part) jusquâ€™ici, &lt;a href=&quot;https://kotlinlang.org/docs/idioms.html&quot;&gt;autant le faire bien et complÃ¨tement&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Kotlin a de multiples talents. Facile dâ€™apprentissage, il emprunte un peu Ã  Typescript, C#, Scala et bien sÃ»r Java, puisquâ€™il produit du bytecode ciblÃ© pour la JVM.&lt;/p&gt;

&lt;p&gt;Son Ã©diteur (Jetbrains) a tout fait pour que les dÃ©veloppeurs Java sâ€™y retrouvent, et puissent mÃªme rÃ©-utiliser nâ€™importe quelle classe du JDK ou nâ€™importe quelle lib Java. Et Ã§a fonctionne trÃ¨s bien. On peut mÃªme Ã©crire du code â€œfaÃ§on Javaâ€ (utiliser des exceptions, mettre des if en pagaille, des null partoutâ€¦).
Bref, si on nâ€™y prenait garde, on Ã©crirait presque du Kotlin qui ressemble Ã  du â€œmauvaisâ€ Java (je veux dire par lÃ  du Java dâ€™avant guerre, avant la version 8 si vous prÃ©fÃ©rezâ€¦).&lt;/p&gt;

&lt;p&gt;Pourtant avec Kotlin, tout est fait pour Ã©crire du code â€œÃ©lÃ©gantâ€. Jâ€™en veux pour preuve la non nullabilitÃ© des types par dÃ©faut, &lt;a href=&quot;https://medium.com/@johnmcclean/dysfunctional-programming-in-java-2-immutability-a2cff487c224&quot;&gt;lâ€™immutabilitÃ©&lt;/a&gt; par dÃ©faut, la prÃ©sence des data classes (Ã©quivalent des Records de C# ou Java 16) parmi tant de choses qui mâ€™ont enchantÃ©es.
On notera aussi que Kotlin dispose nativement de structures de donnÃ©es avancÃ©es (Pair, Triple, Linked List, Tree, etcâ€¦) et de possibilitÃ©s de &lt;a href=&quot;https://www.baeldung.com/kotlin/category/functions&quot;&gt;manipulation de fonctions&lt;/a&gt; qui sont juste dÃ©licieuses.&lt;/p&gt;

&lt;p&gt;Et jâ€™allais oublier de mentionner les trÃ¨s &lt;a href=&quot;https://www.baeldung.com/kotlin/coroutines&quot;&gt;puissantes co-routines&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;attention&quot;&gt;Attention&lt;/h2&gt;

&lt;p&gt;Tout au long de notre travail, une attention particuliÃ¨re a Ã©tÃ© portÃ©e aux autres membres de lâ€™Ã©quipe. Nous avons communiquÃ© rÃ©guliÃ¨rement :&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;sur lâ€™avancÃ©e du projet, mÃªme si nous nâ€™avions pas de revue de sprint (on en parle plus loin), sur les innovations ou techniques que nous avions choisi de mettre en Å“uvre, car celles-ci pouvaient aussi trouver leur place dans dâ€™autres projets du groupe.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Nous sommes aussi dans une dÃ©marche dâ€™invitation permanente : tous les autres membres de la R&amp;amp;D peuvent venir collaborer au projet, apprendre Kotlin ou tout autre concept que nous avons mis en Å“uvre.&lt;/p&gt;

&lt;h2 id=&quot;langage-naturel&quot;&gt;Langage Naturel&lt;/h2&gt;

&lt;p&gt;Le langage des utilisateurs et des experts mÃ©tier a Ã©tÃ© le nÃ´tre tout le long de la rÃ©alisation.&lt;/p&gt;

&lt;p&gt;Pas de jargon de dÃ©veloppeurs.&lt;/p&gt;

&lt;p&gt;Notre domaine mÃ©tier est en franÃ§ais. Toute la modÃ©lisation et le codage du logiciel se sont donc faits dans cette belle langue.&lt;/p&gt;

&lt;p&gt;Nous avons rÃ©servÃ© lâ€™anglais pour les parties purement techniques (logÃ©es dans des composants isolÃ©s et accessibles via les Ports &amp;amp; Adaptateurs, conformÃ©ment Ã  lâ€™architecture hexagonale exposÃ©e plus loin); par exemple la mÃ©canique dâ€™accÃ¨s Ã  la base de donnÃ©es ou au bus de message.&lt;/p&gt;

&lt;p&gt;Câ€™est trÃ¨s pratique pour se rendre compte au premier coup dâ€™Å“il si notre mÃ©tier (en franÃ§ais) reste pur et ne se mÃ©lange pas avec des considÃ©rations techniques (en anglais).&lt;/p&gt;

&lt;h2 id=&quot;stratÃ©gie&quot;&gt;StratÃ©gie&lt;/h2&gt;

&lt;p&gt;Lâ€™approche DDD est un guide dans la nuit. Ce nâ€™est pas Ã  proprement parler une mÃ©thode, et surtout pas un framework. Câ€™est un ensemble dâ€™outils et de bonnes pratiques, tout Ã  fait compatible avec lâ€™agilitÃ© et le software craftsmanship.&lt;/p&gt;

&lt;p&gt;Nous avons eu cette approche dâ€™emblÃ©e, dÃ¨s les premiÃ¨res heures du projet. Câ€™est, il me semble, la condition sine qua non pour rÃ©ussir.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://dev-to-uploads.s3.amazonaws.com/uploads/articles/8o9r2etj2tth05ulw2f9.jpeg&quot; alt=&quot;DDD starter&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Comme dit prÃ©cÃ©demment, jâ€™ai commencÃ© par la mise en place dâ€™une Wardley Map, puis avec &lt;a href=&quot;https://www.linkedin.com/in/damien-boue/&quot;&gt;Damien BouÃ©&lt;/a&gt; nous avons travaillÃ© sur des Bounded Contexts Maps. Cela nous a permis de nous synchroniser aussi avec les Ã©quipes Produit.&lt;/p&gt;

&lt;h2 id=&quot;tactique&quot;&gt;Tactique&lt;/h2&gt;

&lt;p&gt;En DDD la stratÃ©gie sâ€™accompagne toujours dâ€™une tactique, je ne vais pas vous faire ici un cours de DDD, les ressources sur Internet ne manquent pas.&lt;/p&gt;

&lt;p&gt;Je ne vais pas vous parler ici des essentielles dÃ©compositions en agrÃ©gats, entitÃ©s et value objects (chasser la Primitive Obsession).&lt;/p&gt;

&lt;p&gt;Je vous dirai seulement quâ€™une des leÃ§ons que nous avons apprises est de songer sÃ©rieusement Ã  limiter la taille de nos agrÃ©gats ! (cf ces &lt;a href=&quot;https://www.dddcommunity.org/library/vernon_2011/&quot;&gt;bons conseils peu connus de Vaughn Vernon&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;Jusquâ€™Ã  ce quâ€™ils ne contiennent quâ€™une entitÃ©. Cette idÃ©e peut vous paraÃ®tre saugrenue mais vous lui direz merci quand vous verrez la complexitÃ© accidentelle poindre son nez.&lt;/p&gt;

&lt;p&gt;Bien sÃ»r cela demande Ã  rÃ©flÃ©chir plus et surtout Ã  ne pas se laisser entraÃ®ner par une conception basÃ©e sur le Mapping Objet Relationnel (ORM ou Objet Documents Mapping dans le cas des entrepÃ´ts NoSQL) qui, entre autres inconvÃ©nients, pousse notre modÃ¨le Ã  Ãªtre anÃ©mique. Mais aussi lorsque lâ€™exÃ©cution de nos adapters devient concurrente (comme dans toutes les API Web), nous aurait obligÃ© Ã  poser des verrous transactionnels (et donc faire effondrer la performance). Cela est inÃ©vitable lorsque les agrÃ©gats sont trop gros et que lâ€™on veut y accÃ©der en Ã©criture.&lt;/p&gt;

&lt;p&gt;Donc, gardons les atomiques !&lt;/p&gt;

&lt;h2 id=&quot;coeur&quot;&gt;Coeur&lt;/h2&gt;

&lt;p&gt;Lâ€™une des (nombreuses) brillantes idÃ©es de ce projet a Ã©tÃ© de suivre le prÃ©cepte de â€œ&lt;a href=&quot;https://www.destroyallsoftware.com/screencasts/catalog/functional-core-imperative-shell&quot;&gt;Functional Core/ Imperative Shell&lt;/a&gt;â€, introduit en 2012 dans la communautÃ© Ruby, puis repris plus rÃ©cemment par &lt;a href=&quot;https://www.kennethlange.com/&quot;&gt;Kenneth Lange&lt;/a&gt; et aussi par &lt;a href=&quot;https://www.slideshare.net/ThomasPierrain/hexagonal-architecture-vs-functional-core-iom&quot;&gt;Thoman Pierrain &amp;amp; Bruno BOUCARD&lt;/a&gt; ;&lt;/p&gt;

&lt;p&gt;Cette approche a dâ€™Ã©normes avantages, citons-en 2 :&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;dâ€™abord repousser les effets de bord (les fameux, ceux qui rendent vos tests trop compliquÃ©s, plus du tout isolÃ©s, voire inconsistants et cachent de nombreux bugs) en dehors des considÃ©rations mÃ©tier.&lt;/li&gt;
  &lt;li&gt;corollaire : cela vous permet de vous concentrer sur la seule logique mÃ©tier de maniÃ¨re fonctionnelle, câ€™est-Ã -dire en privilÃ©giant &lt;a href=&quot;https://medium.com/@johnmcclean/dysfunctional-programming-in-java-2-immutability-a2cff487c224&quot;&gt;lâ€™immutabilitÃ©&lt;/a&gt; et la &lt;a href=&quot;https://sookocheff.com/post/fp/why-functional-programming/&quot;&gt;transparence rÃ©fÃ©rentielle&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Cette faÃ§on de penser le logiciel en y plaÃ§ant un cÅ“ur purement fonctionnel (dans les 2 sens du terme) permet dâ€™isoler vraiment les tests mÃ©tiers et donc &lt;a href=&quot;https://www.destroyallsoftware.com/blog/2014/test-isolation-is-about-avoiding-mocks&quot;&gt;de se passer entiÃ¨rement des mocks Ã  cet endroit&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Dans le cÅ“ur mÃ©tier propre du Messager sont Ã©galement apparues dâ€™autres frontiÃ¨res, et donc dâ€™autres Bounded Context pour des composants qui avaient besoin de pouvoir Ã©voluer sans casser les autres. Tout ce travail dâ€™&lt;em&gt;isolation&lt;/em&gt; (via des ACL, anti corruption layers) est primordial pour ne pas sâ€™enfermer dans une complexitÃ© accidentelle et dans ce qui devient inexorablement, malgrÃ© toute bonne volontÃ©, une â€œbig ball of mudâ€ (grosse boule de boue).&lt;/p&gt;

&lt;h2 id=&quot;hexagone&quot;&gt;Hexagone&lt;/h2&gt;

&lt;p&gt;Il y a le cÅ“ur fonctionnel, et il y a la coquille (shell en Anglais). Câ€™est ce que lâ€™on retrouve aussi dans les &lt;a href=&quot;https://alistair.cockburn.us/hexagonal-architecture/&quot;&gt;architectures hexagonales&lt;/a&gt; (ou &lt;a href=&quot;https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html&quot;&gt;Clean Architecture&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Dans la partie coquille (hors cÅ“ur mÃ©tier donc) on va retrouver les ports et adaptateurs.&lt;/p&gt;

&lt;p&gt;Câ€™est cette philosophie que nous avons appliquÃ©e fortement.&lt;/p&gt;

&lt;p&gt;Et nous avons fabriquÃ© des adaptateurs techniques pour toute situation spÃ©cifique.&lt;/p&gt;

&lt;p&gt;Lâ€™absorption de commandes venues dâ€™une API REST est un adaptateur indÃ©pendant. Il a une dÃ©pendance directe avec les objets mÃ©tiers.
Par contre pour toute opÃ©ration en base de donnÃ©es (nous avons, en prÃ©vision dâ€™un CQRS sÃ©parÃ© les opÃ©rations de lecture et celles dâ€™Ã©criture), il y a des adaptateurs dÃ©diÃ©s.&lt;/p&gt;

&lt;p&gt;Il en va de mÃªme pour les opÃ©rations dâ€™envoi et de rÃ©ception de messages dans un bus (afin de prÃ©venir les agents dans dâ€™autres Bounded Contexts quâ€™un Ã©vÃ©nement important sâ€™est passÃ© dans notre domaine.&lt;/p&gt;

&lt;h2 id=&quot;qualitÃ©&quot;&gt;QualitÃ©&lt;/h2&gt;

&lt;p&gt;TDD offre ce double avantage dâ€™Ãªtre la mÃ©thode dâ€™Ã©criture du logiciel (et non de test) qui nous a permis de faire du design Ã©mergent guidÃ© par le DDD tactique et de toujours se fixer des petits pas. Et bien sÃ»r, on obtient une couverture de tests trÃ¨s satisfaisante, puisquâ€™aucune ligne de code ne devrait Ãªtre Ã©crite si elle nâ€™est pas justifiÃ©e par un test.&lt;/p&gt;

&lt;p&gt;Kotlin (encore lui !) vient avec une gÃ©niale librairie : Kotest. Attention Ã  ne pas faire comme moi au dÃ©but, de faire la confusion entre KotlinTest et Kotest.&lt;/p&gt;

&lt;p&gt;Câ€™est bien Kotest qui permet de choisir parmi moult styles de tests, il y en a vraiment pour tout le monde : style Behaviour Driven Development (celui que nous avons choisi), style Scala, Ruby, Cucumber ou JavaScript/TypeScript. Ou ce bon vieux JUnit.&lt;/p&gt;

&lt;p&gt;Ã‰crire des tests, câ€™est bien joli, mais encore faut-il sâ€™assurer quâ€™ils servent Ã  quelque chose et quâ€™ils sont robustes.&lt;/p&gt;

&lt;p&gt;Les outils dÃ©jÃ  en place pour les autres projets Java de lâ€™entreprise (Jenkins, SonarQube, un scanner de vulnÃ©rabilitÃ© des dÃ©pendances) se sont parfaitement intÃ©grÃ©s Ã  notre nouveau projet Kotlin.&lt;/p&gt;

&lt;p&gt;La Couverture de code a pu donc Ãªtre constamment mesurÃ©e, mais jâ€™en dirai plus au prochain chapitre.&lt;/p&gt;

&lt;p&gt;Dâ€™autres outils sont venus renforcer cette recherche de qualitÃ© :&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.archunit.org/getting-started&quot;&gt;ArchUnit&lt;/a&gt;, pour vÃ©rifier en permanence le bon usage des dÃ©pendances et &lt;a href=&quot;https://blog.scottlogic.com/2019/12/05/unit-test-your-architecture-with-archunit.html&quot;&gt;vÃ©rifier que nous ne cassions pas les principes de lâ€™architecture hexagonale&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.baeldung.com/introduction-to-gatling&quot;&gt;Gatling&lt;/a&gt; pour sâ€™assurer que notre solution tient la charge en situation rÃ©elle&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;rigueur&quot;&gt;Rigueur&lt;/h2&gt;

&lt;p&gt;Un grand enjeu de la qualitÃ© logicielle semble Ãªtre la couverture de code, mais cette mesure peut sâ€™avÃ©rer erronÃ©e, comme je le prouve dans &lt;a href=&quot;https://www.linkedin.com/posts/guillaumese_des-mutants-dans-le-code-activity-6870318621411876864-RD_g&quot;&gt;ma prÃ©sentation sur les tests par mutation de code&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Dans ce projet, il nous a paru opportun de consolider notre approche TDD, parce quâ€™aprÃ¨s tout nous sommes tous faillibles, et quâ€™un outil qui nous montre que nous manquons de tests, que des bugs sont encore prÃ©sents, est tout simplement une aubaine.&lt;/p&gt;

&lt;p&gt;Nous avons choisi la lib PiTest, qui fonctionne sur le ByteCode Java, et donc trÃ¨s bien avec Kotlin.&lt;/p&gt;

&lt;p&gt;Simple dâ€™usage, facile Ã  ajouter Ã  un pipeline dâ€™intÃ©gration continue, cet outil va nous aider Ã  mieux coder et mieux tester (lâ€™un ne va pas sans lâ€™autre). Il nous a rappelÃ© sans faillir aux rÃ¨gles du TDD (ne pas Ã©crire une instruction qui ne soit justifiÃ©e par un test).&lt;/p&gt;

&lt;p&gt;Par contre, il est avisÃ© dâ€™utiliser ce genre dâ€™outil sur du nouveau code plutÃ´t que sur du legacy, et de cibler du code purement mÃ©tier, câ€™est-Ã -dire au centre (functional core) de lâ€™architecture hexagonale.&lt;/p&gt;

&lt;h2 id=&quot;paradigme-changement-de&quot;&gt;Paradigme (changement de)&lt;/h2&gt;

&lt;p&gt;Ce nâ€™est pas chose facile que de bousculer (un peu) les habitudes des dÃ©veloppeurs. Alors que la programmation orientÃ©e objet est maÃ®trisÃ©e par tous mes collÃ¨gues, je leur ai fait la proposition de parier sur lâ€™immutabilitÃ©.&lt;/p&gt;

&lt;p&gt;Lâ€™immutabilitÃ©, câ€™est quoi ?  Une idÃ©e qui nous vient de la programmation fonctionnelle mais qui sâ€™applique trÃ¨s bien Ã  la POO. Le principe est simple : quand les objets ne â€œmutentâ€ pas (comprendre : ne changent pas dâ€™Ã©tat) alors ils sont plus facile Ã  maÃ®triser, Ã  comprendre et surtout on Ã©vite beaucoup, beaucoup de bugs car on limite grandement les effets de bord dans les mÃ©thodes de ces objets immuables.&lt;/p&gt;

&lt;p&gt;Mieux encore, cette immutabilitÃ© est facile Ã  obtenir avec des langages tels que Kotlin (celui que nous avons choisi pour ce projet) ou mÃªme Java (le mot clÃ© &lt;em&gt;final&lt;/em&gt; existe et il a Ã©tÃ© ensuite complÃ©tÃ© avec des librairies qui poussent une vraie immutabilitÃ© des objets, comme par exemple  &lt;a href=&quot;https://www.baeldung.com/immutables&quot;&gt;https://www.baeldung.com/immutables&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Elle permet de transitionner naturellement vers une Ã©criture de code plus â€œfonctionnelleâ€ câ€™est-Ã -dire avec une meilleur rÃ©partition des responsabilitÃ©s (voir chapitre suivant), et une plus grande intÃ©gritÃ© rÃ©fÃ©rentielle.&lt;/p&gt;

&lt;h2 id=&quot;solide&quot;&gt;Solide&lt;/h2&gt;

&lt;p&gt;Notre attention sâ€™est focalisÃ©e sur la production dâ€™ un code SOLID. Ce nâ€™est pas facile de vous parler des principes dâ€™un code SOLID, surtout que cela fait partie de la grande famille du code â€œpropreâ€ (Clean Code). Le premier principe est peut Ãªtre le plus important et le plus simple Ã  comprendre : Simple Responsibility. Et tous les autres en dÃ©coulent. Nous avons toujours cherchÃ© dans ce projet Ã  exprimer et rÃ©partir les responsabilitÃ©s de faÃ§on trÃ¨s claire et trÃ¨s cohÃ©rente entre les diffÃ©rents modules.&lt;/p&gt;

&lt;p&gt;Que ce soit dans le dÃ©coupage mÃ©tier (Bounded Contexts, DDD StratÃ©gique) ou dans lâ€™approche technique (Archi HÃ©xagonale DDD Tactique), notre objectif a tout le temps Ã©tÃ© de limiter la responsabilitÃ© Ã  un niveau minimal et acceptable, afin de mieux sÃ©parer et isoler ces responsabilitÃ©s. Les cartes CRC nous ont aussi beaucoup aidÃ© Ã  y voir plus clair dans notre design.&lt;/p&gt;

&lt;h2 id=&quot;dÃ©couplÃ©&quot;&gt;DÃ©couplÃ©&lt;/h2&gt;

&lt;p&gt;Le dÃ©couplage est un fondamental Ã  la fois de lâ€™architecture dâ€™un logiciel mais aussi de la journÃ©e ordinaire dâ€™un dÃ©veloppeur. Il sâ€™agit simplement de ne pas accumuler la complexitÃ© et les interactions douteuses qui peuvent se loger dans le code. Pour cela nous avons fait le choix dâ€™abstractions pour dÃ©finir et maÃ®triser ces fameuses dÃ©pendances.&lt;/p&gt;

&lt;p&gt;Lâ€™idÃ©e est dâ€™exprimer simplement les choses en termes de â€œquoiâ€ et non de â€œcommentâ€.&lt;/p&gt;

&lt;p&gt;Exemple : au lieu de dire Ã  notre code â€œje veux une base de donnÃ©es Mongo pour stocker des informationsâ€, nous avons Ã©tabli une abstraction (interface) qui dit â€œje veux pouvoir stocker cette informationâ€. Le â€œcommentâ€ ne nous intÃ©resse absolument pas.&lt;/p&gt;

&lt;p&gt;En se rÃ©fÃ©rant Ã  cette abstraction (â€œJe_veux_stocker_information_Xâ€), nous voilÃ  libres de son implÃ©mentation. Et câ€™est double bÃ©nÃ©fice.&lt;/p&gt;

&lt;p&gt;Dâ€™abord nous pouvons choisir librement lâ€™implÃ©mentation et en changer Ã  tout moment au cours de la vie du projet (nous avons choisi Mongo DB mais peut Ãªtre que ce choix sera remis en cause).&lt;/p&gt;

&lt;p&gt;Et surtout, pendant les tests fonctionnels, nous nâ€™avons pas lâ€™obligation de mettre en route la fameuse base de donnÃ©es Mongo que nous avons choisie pour la production. Nous pouvons juste utiliser un fake, câ€™est-Ã -dire une implÃ©mentation naÃ¯ve, simpliste.&lt;/p&gt;

&lt;h2 id=&quot;evenementiel&quot;&gt;Evenementiel&lt;/h2&gt;

&lt;p&gt;Une autre grande force de ce projet est que nous avons dâ€™emblÃ©e pris en compte la nature Ã©vÃ©nementielle dâ€™une application. Dans un logiciel, il se passe des choses.&lt;/p&gt;

&lt;p&gt;Il est plus important de capturer des Ã©vÃ¨nements que dâ€™enregistrer lâ€™Ã©tat des objets.&lt;/p&gt;

&lt;p&gt;Malheureusement, trop dâ€™applications sont dÃ©veloppÃ©es en mode CRUD (Create Read Update Delete), aidÃ©es (mais pas dans le bon sens) par les frameworks de mapping ORM. Ce mode de dÃ©veloppement rend compliquÃ© toute migration fonctionnelle, car justement il est difficile de placer des rÃ¨gles mÃ©tiers quand on pense que tout se limite Ã  des opÃ©rations dâ€™ajout/modification/suppression/lecture en base de donnÃ©es.&lt;/p&gt;

&lt;p&gt;En pensant Ã©vÃ©nements, on est au contraire ouvert Ã  tout ce qui peut se passer comme vÃ©rifications, contraintes, Ã©volution du mÃ©tier. On est bien plus proche des actions des utilisateurs.&lt;/p&gt;

&lt;p&gt;On peut crÃ©er des programmes plus aptes Ã  rÃ©pondre au besoin mÃ©tier, et moins coincÃ© dans une solution technique.&lt;/p&gt;

&lt;p&gt;En pratique, nos agrÃ©gats mÃ©tiers Ã©mettent des Ã©vÃ©nements, en rÃ©action Ã  des commandes, aprÃ¨s avoir opÃ©rÃ© les vÃ©rifications mÃ©tier qui sâ€™imposent. Nous avons mis en place un mÃ©canisme de remontÃ©e automatique des Ã©vÃ©nements (event bubbling) depuis les entitÃ©s filles qui composent un agrÃ©gat global (grÃ¢ce Ã  ReactiveX et ses &lt;a href=&quot;https://reactivex.io/documentation/observable.html&quot;&gt;Observables&lt;/a&gt;).&lt;/p&gt;

&lt;h2 id=&quot;partage&quot;&gt;Partage&lt;/h2&gt;

&lt;p&gt;Cela a Ã©tÃ© une discussion intÃ©ressante (parmi tant dâ€™autres) : Comment sâ€™y prendre pour se partager le travail et le partager avec les autres ? Bien sÃ»r il y a lâ€™usage de lâ€™attirail Jira, Git, Jenkinsâ€¦ Mais ce qui importe câ€™est surtout la faÃ§on dont on sâ€™en sert.&lt;/p&gt;

&lt;p&gt;Nous avons optÃ© pour des &lt;a href=&quot;https://adr.github.io/&quot;&gt;ADR&lt;/a&gt; dans les points clÃ© de notre repository, afin de garder trace de nos discussions et de remettre en contexte les choix tactiques opÃ©rÃ©s dans le code.&lt;/p&gt;

&lt;p&gt;Nous avons aussi mis lâ€™accent sur le pair programming. Mais nous avions quand mÃªme voulu garder les &lt;a href=&quot;https://trunkbaseddevelopment.com/continuous-review/&quot;&gt;Code Reviews&lt;/a&gt;, pour prendre de la hauteur sur le code produit (essentiellement par Damien BouÃ© et moi mÃªme). Je suis plus partisan du &lt;a href=&quot;https://www.freecodecamp.org/news/why-you-should-not-use-feature-branches-a86950126124/&quot;&gt;Trunk Based Development&lt;/a&gt;, mais en adoptant des tests plus longs Ã  exÃ©cuter comme le Mutation Testing, il Ã©tait intÃ©ressant dâ€™isoler tout nouveau code dans une branche dÃ©diÃ©e afin de voir sâ€™exÃ©cuter correctement  toute la lignÃ©e de tests, sans compromettre la branche principale (on aurait pu faire du &lt;a href=&quot;https://blog.zenika.com/2018/12/03/tdd-est-mort-longue-vie-tcr/&quot;&gt;TCR&lt;/a&gt; mais câ€™est un peu violent).&lt;/p&gt;

&lt;p&gt;Nous avons plutÃ´t optÃ© pour des &lt;a href=&quot;https://trunkbaseddevelopment.com/short-lived-feature-branches/&quot;&gt;Short Lived Branch&lt;/a&gt; avec des rÃ¨gles du jeu : pas plus de 2 branches diffÃ©rentes en simultanÃ© et ne portant pas sur les mÃªmes â€œzonesâ€ du code.&lt;/p&gt;

&lt;p&gt;Au bout dâ€™un moment, nous avions assez dâ€™abstractions (&lt;a href=&quot;https://trunkbaseddevelopment.com/branch-by-abstraction/&quot;&gt;branching by abstraction&lt;/a&gt;) pour Ã©viter des â€œrebaseâ€ douloureux.&lt;/p&gt;

&lt;p&gt;Bien sÃ»r, quand nous avions Ã  faire des refactoring qui touchaient plusieurs endroits du code, il fallait dâ€™abord solder toutes les branches en cours, avant de sâ€™attaquer Ã  des modifications qui auraient eu trop dâ€™impacts sur lâ€™architecture ou les interfaces fondatrices.&lt;/p&gt;

&lt;p&gt;Pour Ã©viter que les refactoring ne durent trop longtemps et ne conduisent Ã  des rÃ©conciliations de code houleuses, jâ€™ai recommandÃ© dâ€™adopter la mÃ©thode &lt;a href=&quot;https://blog.engineering.publicissapient.fr/2020/03/20/domptez-vos-refactoring-avec-la-mikado-method/&quot;&gt;Mikado&lt;/a&gt;, afin, une fois de plus, de progresser par petits pas, de merger trÃ¨s trÃ¨s souvent, de ne pas se lancer dans des travaux dâ€™Hercule, et de se rendre compte des problÃ¨mes au plus tÃ´t.&lt;/p&gt;

&lt;p&gt;Le refactoring devient Ã©galement plus aisÃ© en adoptant la mÃ©thode â€œ&lt;a href=&quot;https://martinfowler.com/bliki/ParallelChange.html&quot;&gt;parallel change&lt;/a&gt;â€ ou â€œ&lt;a href=&quot;https://medium.com/dan-the-dev/refactoring-parallel-change-trunk-based-development-97f38bea86ae&quot;&gt;expand and contract&lt;/a&gt;â€ : on ne casse pas lâ€™existant; on implÃ©mente dans une nouvelle mÃ©thode ce qui doit Ãªtre refactorÃ©, et petit Ã  petit on transite vers le nouveau code, avant dâ€™effacer lâ€™ancien quand il nâ€™est plus utilisÃ© nulle part.&lt;/p&gt;

&lt;p&gt;Encore une fois, lâ€™architecture hexagonale, avec son dÃ©couplage maximum, nous a permis de minimiser la casse.&lt;/p&gt;

&lt;p&gt;Je suis trÃ¨s content dâ€™avoir travaillÃ© comme cela, car les revues de code nous ont permis de se poser la question â€œest ce que notre design reste cohÃ©rentâ€ Ã  chaque Ã©tape de la construction du logiciel.&lt;/p&gt;

&lt;h2 id=&quot;agilitÃ©&quot;&gt;AgilitÃ©&lt;/h2&gt;

&lt;p&gt;Il Ã©tait important dâ€™avoir du feedback rapide mÃªme sur un produit qui nâ€™est pas encore mis en exploitation. Nous avons optÃ© pour un travail en flux type Kanban, avec des jalons variables qui Ã©taient matÃ©rialisÃ©s par des Minor Releases, selon nos dÃ©sidÃ©rata et contraintes.&lt;/p&gt;

&lt;p&gt;Nous avons pu compter sur une IntÃ©gration Continue (CI/CD) super efficace grÃ¢ce au soutien de lâ€™Ã©quipe DevOps en place.&lt;/p&gt;

&lt;h2 id=&quot;rÃ©sultat&quot;&gt;RÃ©sultat&lt;/h2&gt;

&lt;p&gt;Le projet nâ€™est pas encore terminÃ©, et vous nâ€™en verrez pas une dÃ©monstration graphique, car ce nâ€™est quâ€™un composant au milieu de tant dâ€™autres. Mais comme il va devenir un maillon fort de lâ€™Ã©difice logiciel de Primobox, câ€™est la fiabilitÃ©, la rapiditÃ© et la performance de produits qui vont sâ€™en trouver renforcÃ©es. Ainsi que la maÃ®trise technique des Ã©quipes R&amp;amp;D.&lt;/p&gt;

&lt;h2 id=&quot;exemplaire&quot;&gt;Exemplaire&lt;/h2&gt;

&lt;p&gt;Ce qui est dâ€™emblÃ©e visible ce sont les mÃ©triques dâ€™un code de qualitÃ©, tel que peut nous les montrer Sonarqube. Et pour moi câ€™est une grande fiertÃ© dâ€™avoir contribuÃ© Ã  ce projet.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://dev-to-uploads.s3.amazonaws.com/uploads/articles/k30y78firzt2xl93svso.png&quot; alt=&quot;Image description&quot; /&gt;&lt;/p&gt;

&lt;!-- Footnotes themselves at the bottom. --&gt;
&lt;h2 id=&quot;notes&quot;&gt;Notes&lt;/h2&gt;

&lt;p&gt;Discret au sens mathÃ©matique du terme : qui est clairement dÃ©limitÃ©, sÃ©parÃ©, isolÃ©.&lt;/p&gt;
&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;

      &lt;p&gt;&lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Wed, 02 Feb 2022 00:00:00 -0600</pubDate>
        <link>http://0.0.0.0:4000/le-messager/</link>
        <guid isPermaLink="true">http://0.0.0.0:4000/le-messager/</guid>
        
        
        <category>Domain Driven Design</category>
        
        <category>Architecture</category>
        
        <category>Retour d'expÃ©rience</category>
        
      </item>
    
      <item>
        <title>L'Outside-in Diamond TDD, ou l'art de mieux tester</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Image dâ€™illustration : Copyright 42skillz / Thomas PIERRAIN&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;le-besoin&quot;&gt;Le besoin&lt;/h2&gt;

&lt;p&gt;DÃ©velopper de bons tests unitaires nâ€™est pas une tÃ¢che aisÃ©e. MÃªme les dÃ©veloppeurs les plus expÃ©rimentÃ©s peuvent tomber dans les piÃ¨ges â€œclassiquesâ€ de la pratique du dÃ©veloppement des tests automatisÃ©s.&lt;/p&gt;

&lt;p&gt;Les plus courants sont :&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Les tests fragiles&lt;/strong&gt; : ce que lâ€™on teste dans ceux-ci est souvent lâ€™implÃ©mentation, dÃ» Ã  lâ€™utilisation excessive de mocks. Lors dâ€™un refactoring, ils devront Ãªtre mis Ã  jour systÃ©matiquement et ce sera coÃ»teux.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Les tests â€œinutilesâ€&lt;/strong&gt; : ce sont des tests qui couvrent du code trivial, et qui nâ€™apportent pas de plus-value au projet. Ce sont des tests qui ne sont pas orientÃ©s mÃ©tier. Par exemple : un test qui va tester une classe de mapping.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Les tests trop complexes&lt;/strong&gt; : ceux-ci sont souvent des tests dâ€™intÃ©gration qui nÃ©cessitent beaucoup de plomberie (liÃ©e aux prÃ©requis) que lâ€™on ne voit pas. De ce fait, ils deviennent rapidement trÃ¨s difficiles Ã  maintenir. Ils sont souvent trÃ¨s lents Ã  exÃ©cuter, difficiles Ã  comprendre et portent sur du code complexe avec de nombreuses lignes de code.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Mais alors, comment peut-on rÃ©aliser des tests plus robustes ? Pour cela, laissez-moi vous prÃ©senter lâ€™&lt;strong&gt;Outside-in Diamond TDD&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&quot;quest-ce-que-loutside-in-diamond-tdd-&quot;&gt;Quâ€™est ce que lâ€™Outside-in Diamond TDD ?&lt;/h2&gt;

&lt;p&gt;Lâ€™Outside-in Diamond TDD est une technique dâ€™approche des tests unitaires mise au point par &lt;a href=&quot;http://tpierrain.blogspot.com/&quot;&gt;&lt;strong&gt;Thomas Pierrain&lt;/strong&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Lâ€™idÃ©e de base est nÃ©e dâ€™une constatation : la notion de tests unitaires est mal comprise par la majoritÃ© des dÃ©veloppeurs. En effet, ceux-ci pensent quâ€™un test unitaire est un bout de code qui va tester un petit composant en isolation des autres. Or, comme le fait si bien remarquer Thomas Pierrain, la dÃ©finition de &lt;a href=&quot;https://fr.wikipedia.org/wiki/Kent_Beck&quot;&gt;&lt;strong&gt;Kent Beck&lt;/strong&gt;&lt;/a&gt; est beaucoup plus juste :&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Tests that â€œruns in isolationâ€ from other tests (des tests qui sâ€™exÃ©cutent en isolation des autres tests)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Un bon test unitaire sâ€™isole donc lui-mÃªme des autres tests, il nâ€™isole pas le composant quâ€™il teste des autres composants. Cela veut dire que lâ€™on peut faire des tests unitaires qui ne testent pas quâ€™une classe. Ce nâ€™est pas tout : un bon test unitaire sâ€™isole avant tout des dÃ©pendances externes (base de donnÃ©es, disque, API externeâ€¦).&lt;/p&gt;

&lt;p&gt;De plus, Thomas Pierrain a constatÃ© que la &lt;a href=&quot;https://martinfowler.com/bliki/TestPyramid.html&quot;&gt;&lt;strong&gt;pyramide des tests&lt;/strong&gt;&lt;/a&gt; est souvent utilisÃ©e de maniÃ¨re dogmatique sans que les dÃ©veloppeurs ne se posent la question de ce qui est pertinent Ã  tester.&lt;/p&gt;

&lt;p&gt;Pendant longtemps, il a cherchÃ© Ã  lutter pour faire oublier ces fausses idÃ©es, sans succÃ¨s. Jâ€™aime bien sa rÃ©fÃ©rence Ã  la loi dâ€™&lt;a href=&quot;https://fr.wikipedia.org/wiki/Loi_de_Brandolini&quot;&gt;&lt;strong&gt;Alberto Brandolini&lt;/strong&gt;&lt;/a&gt; Ã  propos de ce sujet :&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;â€œThe amount of energy needed to refute bullshit is an order of magnitude larger than to produce itâ€&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Donc plutÃ´t que de lutter inutilement pour faire admettre ces idÃ©es, Thomas Pierrain est parti sur lâ€™idÃ©e de promouvoir les &lt;a href=&quot;https://fr.wikipedia.org/wiki/Test_d%27acceptation&quot;&gt;&lt;strong&gt;tests dâ€™acceptation&lt;/strong&gt;&lt;/a&gt;. En effet, ceux-ci sont plus faciles Ã  faire accepter pour voir le systÃ¨me Ã  tester comme une boÃ®te noire. Les dÃ©veloppeurs auront alors plutÃ´t tendance Ã  tester en termes de contrat mÃ©tier, ce qui est plus sain pour la maintenabilitÃ© des projets.&lt;/p&gt;

&lt;h4 id=&quot;outside-in&quot;&gt;Outside-in&lt;/h4&gt;

&lt;p&gt;La notion dâ€™&lt;strong&gt;Outside-in TDD&lt;/strong&gt; est assez simple Ã  comprendre : on teste de lâ€™extÃ©rieur en allant vers lâ€™intÃ©rieur.&lt;/p&gt;

&lt;p&gt;On commence donc par Ã©crire des &lt;strong&gt;tests dâ€™acceptation&lt;/strong&gt; â€œgros grainsâ€ qui sont orientÃ©s mÃ©tier et testent le systÃ¨me en boÃ®te noire. Pendant la phase red de TDD portant sur ces tests gros grains, on peut Ãªtre amenÃ© Ã  rÃ©aliser des boucles TDD plus petites sur lâ€™intÃ©rieur du systÃ¨me, typiquement sur le modÃ¨le du domaine. A la fin, une fois toutes ces petites boucles rÃ©alisÃ©es, la boucle principale â€œgros grainâ€ deviendra alors passante.&lt;/p&gt;

&lt;h4 id=&quot;diamond&quot;&gt;Diamond&lt;/h4&gt;

&lt;p&gt;La notion de &lt;strong&gt;Diamond&lt;/strong&gt; vient du fait que les tests rÃ©alisÃ©s changent complÃ¨tement la pyramide de test telle que nous la connaissons.&lt;/p&gt;

&lt;p&gt;Le diamant est fait pour symboliser lâ€™importance et la prÃ©pondÃ©rance de ces tests dâ€™acceptation par rapport aux autres types de tests (cf. image en haut de lâ€™article) : tests unitaires, tests dâ€™intÃ©gration, tests end-to-end.&lt;/p&gt;

&lt;p&gt;Ce style de TDD nous oriente donc Ã  Ã©crire plus de tests haut niveau et moins de tests dans le dÃ©tail.&lt;/p&gt;

&lt;h2 id=&quot;pourquoi-loutside-in-diamond-tdd-est-si-intÃ©ressant-&quot;&gt;Pourquoi lâ€™Outside-in Diamond TDD est si intÃ©ressant ?&lt;/h2&gt;

&lt;p&gt;Cela fait quelques annÃ©es maintenant que jâ€™utilise lâ€™&lt;a href=&quot;https://fr.wikipedia.org/wiki/Architecture_hexagonale_(logiciel)&quot;&gt;&lt;strong&gt;architecture hexagonale&lt;/strong&gt;&lt;/a&gt; dans mes projets en production. Jâ€™ai toujours privilÃ©giÃ© les tests unitaires au niveau de mon modÃ¨le de domaine, en les construisant Ã  partir des diffÃ©rents cas manipulÃ©s par mes services applicatifs.&lt;/p&gt;

&lt;p&gt;Le schÃ©ma ci-dessous reprÃ©sente &lt;strong&gt;en vert la partie couverte&lt;/strong&gt; par les tests unitaires tels que je les rÃ©alisais :&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../assets/images/outside-in-diamond-tdd/old-hexagon-tests.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Cela pose un problÃ¨me majeur&lt;/strong&gt;. Il y a tout une partie de code qui se retrouve non testÃ©e : les adaptateurs de gauche (API REST par exemple) et les adaptateurs de droite (base de donnÃ©es par exemple). Ces parties sont matÃ©rialisÃ©es en jaune sur le schÃ©ma. Bien sÃ»r, ils Ã©taient couverts par les tests dâ€™intÃ©gration, mais les tests dâ€™intÃ©gration sont &lt;u&gt;lents&lt;/u&gt;.&lt;/p&gt;

&lt;p&gt;Thomas Pierrain nous fait le retour dâ€™expÃ©rience suivant : la plupart des bugs subtils proviennent de ce code non testÃ©, prÃ©sent dans les adaptateurs. Il prÃ©conise donc de tester &lt;strong&gt;&lt;u&gt;tout l'hexagone&lt;/u&gt;&lt;/strong&gt;, en partant des adaptateurs de gauche, ainsi quâ€™en incluant les adaptateurs de droite (en mockant ou fakant uniquement les I/O, que ce soit de la base de donnÃ©es, du fichier ou du rÃ©seau).&lt;/p&gt;

&lt;p&gt;Câ€™est lÃ  tout lâ€™intÃ©rÃªt de ce pattern de tests : on a des tests Ã  la fois &lt;strong&gt;rapides&lt;/strong&gt; et qui couvrent &lt;strong&gt;largement&lt;/strong&gt; notre base de code.&lt;/p&gt;

&lt;p&gt;On a alors un code couvert comme cela :&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../assets/images/outside-in-diamond-tdd/new-hexagon-tests.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Voyons maintenant un exemple de code pour ces tests (gestion de panier sur un site de e-commerce) :&lt;/p&gt;

&lt;noscript&gt;&lt;pre&gt;400: Invalid request&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/83f89ba6a992b4b7e852f440c307710c.js&quot;&gt; &lt;/script&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Finalement, quâ€™est ce que câ€™est quâ€™un &lt;em&gt;â€œbonâ€&lt;/em&gt; test unitaire ? Il existe autant de dÃ©finitions dâ€™un bon test quâ€™il existe de dÃ©veloppeurs.&lt;/p&gt;

&lt;p&gt;Pour moi, un bon test unitaire est un test qui va &lt;strong&gt;tester un contrat mÃ©tier&lt;/strong&gt;, sans se prÃ©occuper de lâ€™implÃ©mentation. De cette maniÃ¨re, il pourra survivre Ã  tous les refactorings.&lt;/p&gt;

&lt;p&gt;Mais ce nâ€™est pas tout. Un bon test unitaire doit Ãªtre &lt;strong&gt;parlant&lt;/strong&gt;. Il doit Ãªtre &lt;strong&gt;concis&lt;/strong&gt;. Malheureusement, le code des tests unitaires est souvent considÃ©rÃ© comme moins important que le code de production et câ€™est une erreur. Il faut quâ€™il soit traitÃ© avec la plus grande attention. Je vais mÃªme aller plus loin : si un test est bien Ã©crit, il sera la documentation de votre use case que vous nâ€™Ã©crirez jamais.&lt;/p&gt;

&lt;p&gt;Personnellement, jâ€™aime bien lâ€™approche proposÃ©e par &lt;a href=&quot;https://techleadjournal.dev/episodes/58/&quot;&gt;&lt;strong&gt;Vladimir Khorikov&lt;/strong&gt;&lt;/a&gt; pour dÃ©finir la valeur dâ€™un test. Pour lui, les 4 piliers fondamentaux dâ€™un bon test sont :&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;quâ€™il doit permettre dâ€™intercepter une rÃ©gression&lt;/li&gt;
  &lt;li&gt;quâ€™il doit rÃ©sister aux refactorings (grÃ¢ce au fait quâ€™il ne soit pas liÃ© Ã  lâ€™implÃ©mentation du systÃ¨me testÃ©)&lt;/li&gt;
  &lt;li&gt;quâ€™il doit fournir un feedback trÃ¨s rapide&lt;/li&gt;
  &lt;li&gt;quâ€™il doit avoir un coÃ»t de maintenance faible&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Je trouve que les tests rÃ©alisÃ©s en Outside-in Diamond TDD remplissent trÃ¨s bien ces fonctions :&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ils interceptent bien les rÃ©gressions car ce sont des tests dâ€™acceptation orientÃ©s mÃ©tier qui testent du comportement. Si celui-ci change, alors on le sait immÃ©diatement.&lt;/li&gt;
  &lt;li&gt;ils rÃ©sistent au refactoring car on teste en boÃ®te noire lâ€™hexagone complet en partant des adaptateurs de gauche&lt;/li&gt;
  &lt;li&gt;ils sont rapides, car on utilise le moins de frameworks possible et on mock les I/O (BDD, systÃ¨me de fichiers, rÃ©seauâ€¦)&lt;/li&gt;
  &lt;li&gt;ils ont un coÃ»t de maintenance faible de par leur nature â€œmÃ©tierâ€&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Un autre avantage indÃ©niable que je trouve Ã  ce pattern de TDD : il permet dâ€™Ã©crire &lt;strong&gt;moins de tests&lt;/strong&gt; et &lt;strong&gt;mieux&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Chez &lt;strong&gt;Primobox&lt;/strong&gt;, nous mettons en place ce pattern de tests afin de pÃ©renniser nos projets sur le long terme.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Sources :&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://tpierrain.blogspot.com/2021/03/outside-in-diamond-tdd-1-style-made.html&quot;&gt;Outside-in Diamond ğŸ”· TDD #1 - a style made from (&amp;amp; for) ordinary people&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://tpierrain.blogspot.com/2021/03/outside-in-diamond-tdd-2-anatomy-of.html&quot;&gt;Outside-in Diamond ğŸ”· TDD #2 (anatomy of a style)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://techleadjournal.dev/episodes/58/&quot;&gt;Tech Lead Journal #58 - Principles for Writing Valuable Unit Tests - Vladimir Khorikov&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 15 Jan 2022 00:00:00 -0600</pubDate>
        <link>http://0.0.0.0:4000/outside-in-tdd-diamond/</link>
        <guid isPermaLink="true">http://0.0.0.0:4000/outside-in-tdd-diamond/</guid>
        
        
        <category>TDD</category>
        
        <category>Architecture</category>
        
      </item>
    
  </channel>
</rss>
